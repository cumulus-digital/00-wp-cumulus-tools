import { h, render, Fragment } from 'preact';
import { useCallback, useLayoutEffect, useMemo } from 'preact/hooks';
import { useSignal, useSignalEffect } from '@preact/signals';

import config from './config.js';
import { store } from './store.js';
import Filters from './Filters.psx';
import StationList from './StationList.psx';
import Loading from './Loading.psx';

class FetchError extends Error {
	constructor( message ) {
		super( message );
		this.name = 'FetchError';
	}
}
class JsonError extends Error {
	constructor( message ) {
		super( message );
		this.name = 'JsonError';
	}
}

const place = document.querySelectorAll(
	'.wp-block-cumulus-gutenberg-station-finder'
);
if ( place?.length ) {
	place.forEach( ( p ) => {
		p.innerHTML = config?.loading_message
			? config.loading_message
			: '<div class="crsg-loading"></div>';
	} );
}

const polyfillIntersectionObserver = ( callback, global ) => {
	if (
		'IntersectionObserver' in global &&
		'IntersectionObserverEntry' in global &&
		'intersectionRatio' in global.IntersectionObserverEntry.prototype
	) {
		callback( true );
		return;
	}

	const script = global.document.createElement( 'script' );
	script.src =
		'https://www.gstatic.com/external_hosted/intersectionobserver_polyfill/intersection-observer.min.js';
	script.onload = () => callback( true );
	script.onerror = () => callback( false );
	global.document.body.appendChild( script );
};

polyfillIntersectionObserver( ( success ) => {
	if ( success ) {
		const place = document.querySelectorAll(
			'.wp-block-cumulus-gutenberg-station-finder'
		);
		if ( place?.length ) {
			place.forEach( ( p ) => {
				p.innerHTML = '';
				render( <StationFinder />, p );
			} );
		} else {
			console.error(
				'Station finder FE included, but no placements were found.'
			);
		}
	} else {
		console.error(
			'Station finder FE included, but IntersectionObserver polyfill failed to load.'
		);
	}
}, window.self );

function StationFinder( props ) {
	const refreshTime = config.refreshTime ? config.refreshTime : 14400000;
	let refreshTimer;

	const Content = useSignal( <Loading /> );
	useSignalEffect( () => {
		if ( store.error ) {
			Content.value = <p class="error">{ store.status }</p>;
		} else if ( ! store._stations.length ) {
			Content.value = <Loading />;
		} else {
			Content.value = (
				<div class="crsg-stationfinder">
					<Filters />
					<StationList />
				</div>
			);
		}
	} );

	const fetchStations = useCallback( () => {
		store.error = false;
		store.loading = true;
		console.debug( 'StationFinder', 'Fetching stations' );
		fetch( config.baseURL, { method: 'GET', headers: config.headers } )
			.then( ( resp ) => {
				if ( resp.status !== 200 ) {
					throw new FetchError( resp.statusText );
				}

				resp.json()
					.then( ( data ) => {
						store.loading = false;
						store._stations = data;
						console.debug( 'StationFinder', 'Fetch complete.' );
					} )
					.catch( ( err ) => {
						throw new JsonError( err.message );
					} );
			} )
			.catch( ( err ) => {
				store.error = true;
				store.loading = false;
				store.status = config.error_message;
				console.error( 'StationFinder', err.name, err.message );
			} );
	} );

	const doFetchTime = useCallback( () => {
		if ( refreshTimer ) clearTimeout( refreshTimer );

		fetchStations();

		refreshTimer = setTimeout(
			() => {
				doFetchTime();
			},
			Math.random( refreshTime ) + refreshTime
		);
	}, [] );

	useLayoutEffect( () => {
		doFetchTime();

		return () => {
			if ( refreshTimer ) clearTimeout( refreshTimer );
			refreshTimer = null;
		};
	}, [] );

	return Content;
}

export default StationFinder;
